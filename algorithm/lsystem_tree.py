import numpy as np
import os
import sys
from scipy.spatial.transform import Rotation
import matplotlib.pyplot as plt

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from algorithm.lsystem import LSystem
from utils.constants import TREE_EXAMPLE, SETH_TREE, BUSH_3D, ZONO_TREE, REALISTIC_TREE, PLANT_SYSTEM


class LSystemTree:
    """
    Parses a 3D L-system string and generates its geometric representation for visualization.

    This version uses scipy.spatial.transform.Rotation for robust and simple
    handling of 3D orientations.
    """

    def __init__(self, lsystem_string, branch_length=1.0, angle_deg=22.5, initial_diameter=1.0, diameter_scale=0.8):
        """
        Initializes and processes the L-system string.

        Args:
            lsystem_string (str): The string generated by the L-system rules.
            branch_length (float): The length of each 'F' or 'S' segment.
            angle_deg (float): The angle in degrees for rotation commands.
            initial_diameter (float): Starting diameter for trunk/main branches.
            diameter_scale (float): Factor to multiply diameter when '!' is encountered.
        """
        self.lsystem_string = lsystem_string
        self.branch_length = branch_length
        self.angle_rad = np.radians(angle_deg)
        self.initial_diameter = initial_diameter
        self.diameter_scale = diameter_scale

        # Pre-calculate rotation objects for each command
        self._setup_rotations()

        # Generate the list of branches upon instantiation
        self.branches = self._generate_branches()

    def _setup_rotations(self):
        """Pre-computes the rotation objects for cleaner processing."""
        # Define turtle's local coordinate axes
        self.UP_AXIS = np.array([0, 1, 0])  # Yaw axis
        self.LEFT_AXIS = np.array([1, 0, 0])  # Pitch axis
        self.FWD_AXIS = np.array([0, 0, 1])  # Roll axis

        self.rotations = {
            # Yaw
            "+": Rotation.from_rotvec(self.angle_rad * self.UP_AXIS),  # Yaw Left
            "-": Rotation.from_rotvec(-self.angle_rad * self.UP_AXIS),  # Yaw Right
            # Pitch
            "&": Rotation.from_rotvec(self.angle_rad * self.LEFT_AXIS),  # Pitch Down
            "^": Rotation.from_rotvec(-self.angle_rad * self.LEFT_AXIS),  # Pitch Up
            # Roll
            "\\": Rotation.from_rotvec(self.angle_rad * self.FWD_AXIS),  # Roll Left
            "/": Rotation.from_rotvec(-self.angle_rad * self.FWD_AXIS),  # Roll Right
            # Turn around
            "|": Rotation.from_rotvec(np.pi * self.UP_AXIS),
        }

    def _generate_branches(self, position=np.array([0.0, 0.0, 0.0])):
        """
        Parses the L-system string using a 3D turtle and returns a list of branches.
        Now includes diameter tracking with the '!' symbol.
        """
        branches = []
        stack = []
        orientation = Rotation.identity()
        current_diameter = self.initial_diameter

        for char in self.lsystem_string:
            if char in self.rotations:
                # Apply rotation by composing it with the current orientation
                orientation = orientation * self.rotations[char]

            elif char == "[":
                # Push state onto the stack (including diameter)
                stack.append((position, orientation, current_diameter))

            elif char == "]":
                # Pop state from the stack (including diameter)
                position, orientation, current_diameter = stack.pop()

            elif char == "!":
                # Decrement diameter
                current_diameter *= self.diameter_scale

            elif char in ["F", "S", "L", "A", "I", "C"]:  # Draw forward
                # Get current heading by rotating the base "forward" vector
                heading_vec = orientation.apply(self.FWD_AXIS)

                start_point = position
                end_point = start_point + heading_vec * self.branch_length
                # Now store branches as (start, end, type, diameter)
                branches.append((start_point, end_point, char, current_diameter))
                position = end_point  # Move to the new position

            elif char == "f":  # Move forward without drawing
                heading_vec = orientation.apply(self.FWD_AXIS)
                position += heading_vec * self.branch_length

        return branches

    def generate_batch_trees(
        self, world_bounds=np.array([0.0, -10.0, 0.0, 25.0, 10.0, 10.0]), num_batches=1
    ):
        """
        Generate multiple trees at random positions within world bounds.

        Args:
            world_bounds: Array/list of 6 elements [x_min, y_min, z_min, x_max, y_max, z_max]
            num_batches: Number of trees to generate

        Returns:
            List of branch lists, one for each generated tree
        """
        # Validate input
        if len(world_bounds) != 6:
            raise ValueError(
                "world_bounds must have 6 elements: [x_min, y_min, z_min, x_max, y_max, z_max]"
            )

        total_branches = []
        buffer = 6

        # Extract bounds for clarity
        x_min, y_min, z_min = world_bounds[0], world_bounds[1], world_bounds[2]
        x_max, y_max, z_max = world_bounds[3], world_bounds[4], world_bounds[5]

        # Ensure we have enough space after applying buffer
        if (x_max - x_min) <= 2 * buffer or (y_max - y_min) <= 2 * buffer:
            print(f"Warning: Buffer ({buffer}) may be too large for world bounds")

        for i in range(num_batches):
            # Generate random position within buffered bounds
            x = np.random.uniform(x_min + buffer, x_max - buffer)
            y = np.random.uniform(y_min + buffer, y_max - buffer)
            z = z_min

            pos = np.array([x, y, z])
            tree_branches = self._generate_branches(position=pos)
            total_branches.append(tree_branches)

        return total_branches

    def visualize_3d(
        self,
        title="L-System 3D Visualization",
        branch_colors=None,
        figsize=(12, 9),
        elev=25,
        azim=-60,
    ):
        """Creates a 3D visualization of the L-system using matplotlib."""
        if branch_colors is None:
            branch_colors = {
                "F": "saddlebrown",
                "S": "darkgreen",
                "L": "green",
                "C": "limegreen",
                "A": "orange",
                "default": "gray",
            }

        fig = plt.figure(figsize=figsize)
        ax = fig.add_subplot(111, projection="3d")

        all_points = [np.array([0.0, 0.0, 0.0])]
        for start, end, btype, diameter in self.branches:
            # Use diameter to set linewidth (with a minimum width)
            linewidth = max(0.5, diameter * 2.0)
            ax.plot(
                *zip(start, end), color=branch_colors.get(btype, "gray"), linewidth=linewidth
            )
            all_points.extend([start, end])

        # Set plot limits to create a bounding box
        pts = np.array(all_points)
        max_range = (pts.max(axis=0) - pts.min(axis=0)).max() / 2.0
        mid = (pts.max(axis=0) + pts.min(axis=0)) / 2.0
        ax.set_xlim(mid[0] - max_range, mid[0] + max_range)
        ax.set_ylim(mid[1] - max_range, mid[1] + max_range)
        ax.set_zlim(mid[2] - max_range, mid[2] + max_range)

        ax.set_xlabel("X")
        ax.set_ylabel("Y")
        ax.set_zlabel("Z")
        ax.set_title(title)
        ax.view_init(elev=elev, azim=azim)
        plt.tight_layout()
        plt.show()


# --- Example Usage ---
if __name__ == "__main__":
    name, axiom, rule = ZONO_TREE
    lsystem = LSystem(axiom=axiom, rule=rule)
    lsystem.iterate(iterations=7) # zono_tree = 7
    
    lsystem.remove_symbol("A")
    string = lsystem.state

    print(f"Processing L-System for '{name}' with {len(string)} commands...")

    # 2. Create the visualizer object, which processes the string automatically
    tree_viz = LSystemTree(string, branch_length=0.2, angle_deg=22.5, initial_diameter=10.0, diameter_scale=0.85) # zono tree = 22.5

    # 3. Visualize the generated branches
    print("Creating 3D visualization...")
    tree_viz.visualize_3d(title="Simplified 3D L-System Tree")
