import numpy as np
import os
import sys
from scipy.spatial.transform import Rotation
import matplotlib.pyplot as plt

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from algorithm.lsystem import LSystem
from utils.constants import (
    TREE_EXAMPLE,
    SETH_TREE,
    BUSH_3D,
    ZONO_TREE,
    REALISTIC_TREE,
    PLANT_SYSTEM,
)


class LSystemTree:
    """
    Parses a 3D L-systems string and generates its geometric representation for visualization.

    This version uses scipy.spatial.transform.Rotation for robust and simple
    handling of 3D orientations.
    """

    def __init__(
        self,
        lsystem_string,
        branch_length=1.0,
        angle_deg=22.5,
        initial_diameter=1.0,
        diameter_scale=0.8,
    ):
        """
        Initializes and processes the L-system string.

        Args:
            lsystem_string (str): The string generated by the L-system rules.
            branch_length (float): The length of each 'F' or 'S' segment.
            angle_deg (float): The angle in degrees for rotation commands.
            initial_diameter (float): Starting diameter for trunk/main branches.
            diameter_scale (float): Factor to multiply diameter when '!' is encountered.
        """
        self.lsystem_string = lsystem_string
        self.branch_length = branch_length
        self.angle_rad = np.radians(angle_deg)
        self.initial_diameter = initial_diameter
        self.diameter_scale = diameter_scale

        # Pre-calculate rotation objects for each command
        self._setup_rotations()

        # Generate the list of branches upon instantiation
        self.branches, self.branch_groups = self._generate_branches()

    def _setup_rotations(self):
        """Pre-computes the rotation objects for cleaner processing."""
        # Define turtle's local coordinate axes
        self.UP_AXIS = np.array([0, 1, 0])  # Yaw axis
        self.LEFT_AXIS = np.array([1, 0, 0])  # Pitch axis
        self.FWD_AXIS = np.array([0, 0, 1])  # Roll axis

        self.rotations = {
            # Yaw
            "+": Rotation.from_rotvec(self.angle_rad * self.UP_AXIS),  # Yaw Left
            "-": Rotation.from_rotvec(-self.angle_rad * self.UP_AXIS),  # Yaw Right
            # Pitch
            "&": Rotation.from_rotvec(self.angle_rad * self.LEFT_AXIS),  # Pitch Down
            "^": Rotation.from_rotvec(-self.angle_rad * self.LEFT_AXIS),  # Pitch Up
            # Roll
            "\\": Rotation.from_rotvec(self.angle_rad * self.FWD_AXIS),  # Roll Left
            "/": Rotation.from_rotvec(-self.angle_rad * self.FWD_AXIS),  # Roll Right
            # Turn around
            "|": Rotation.from_rotvec(np.pi * self.UP_AXIS),
        }

    def _is_terminal_branch(self, string_index):
        """
        Determine if a branch at the given string index is terminal (green) or not (brown).
        A branch is terminal if:
        - No drawing symbol follows it at the same bracket level
        - No sub-branch '[' starts after it at the same bracket level
        """
        drawing_symbols = {'F', 'S', 'L', 'A', 'I', 'C'}
        bracket_depth = 0
        
        for j in range(string_index + 1, len(self.lsystem_string)):
            next_char = self.lsystem_string[j]
            
            if next_char == '[':
                if bracket_depth == 0:
                    # A sub-branch is starting at our level - we're not terminal
                    return False
                bracket_depth += 1
            elif next_char == ']':
                if bracket_depth == 0:
                    # We hit a closing bracket at our level - this is terminal
                    return True
                bracket_depth -= 1
            elif next_char in drawing_symbols and bracket_depth == 0:
                # Found another drawing symbol at the same bracket level
                return False
        
        # Reached end of string without finding another branch at this level
        return True

    def _generate_branches(self, position=np.array([0.0, 0.0, 0.0])):
        """
        Parses the L-system string and returns branches grouped by alignment and color.
        Each group contains branches that are in a straight line and have the same color.
        """
        branches = []  # For flat list compatibility
        stack = []
        orientation = Rotation.identity()
        current_diameter = self.initial_diameter

        for i, char in enumerate(self.lsystem_string):
            if char in self.rotations:
                # Apply rotation by composing it with the current orientation
                orientation = orientation * self.rotations[char]

            elif char == "[":
                # Push state onto the stack (including diameter)
                stack.append((position, orientation, current_diameter))

            elif char == "]":
                # Pop state from the stack (including diameter)
                position, orientation, current_diameter = stack.pop()

            elif char == "!":
                # Decrement diameter
                current_diameter *= self.diameter_scale

            elif char in ["F", "S", "L", "A", "I", "C"]:  # Draw forward
                # Get current heading by rotating the base "forward" vector
                heading_vec = orientation.apply(self.FWD_AXIS)

                start_point = position
                end_point = start_point + heading_vec * self.branch_length

                # Determine color: 'I' (trunk) is always brown, otherwise check if terminal
                if char == 'I':
                    color = 'B'  # Trunk segments are always brown
                else:
                    is_terminal = self._is_terminal_branch(i)
                    color = 'G' if is_terminal else 'B'

                # Store branch with its direction vector and color
                new_branch = (start_point, end_point, char, current_diameter, heading_vec, color)
                branches.append(new_branch)
                position = end_point

            elif char == "f":  # Move forward without drawing
                heading_vec = orientation.apply(self.FWD_AXIS)
                position += heading_vec * self.branch_length

        # Now group branches by direction, spatial connectivity, AND color
        branch_groups = []
        used = [False] * len(branches)
        angle_threshold = np.radians(0.1)  # Small angle tolerance for alignment
        position_threshold = 1e-6  # Tolerance for end-to-start connection

        for i, (start_i, end_i, type_i, diam_i, dir_i, color_i) in enumerate(branches):
            if used[i]:
                continue

            # Start a new group with this branch
            current_group = [(start_i, end_i, type_i, diam_i, color_i)]
            used[i] = True
            current_end = end_i

            # Try to extend the group by finding connected branches with similar direction AND same color
            found_continuation = True
            while found_continuation:
                found_continuation = False
                
                for j in range(len(branches)):
                    if used[j]:
                        continue

                    start_j, end_j, type_j, diam_j, dir_j, color_j = branches[j]

                    # Check if this branch connects to the end of our current chain
                    distance_to_current = np.linalg.norm(start_j - current_end)
                    
                    if distance_to_current < position_threshold:
                        # Check if colors match
                        if color_j != color_i:
                            continue
                        
                        # Check if directions are similar (angle between them is small)
                        dot_product = np.dot(dir_i, dir_j)
                        angle_diff = np.arccos(np.clip(dot_product, -1.0, 1.0))

                        if angle_diff < angle_threshold:
                            current_group.append((start_j, end_j, type_j, diam_j, color_j))
                            used[j] = True
                            current_end = end_j
                            found_continuation = True
                            break  # Start over to find next connected branch

            branch_groups.append(current_group)

        # Convert branches back to 5-tuple format (without direction vector, but with color)
        branches = [(s, e, t, d, c) for s, e, t, d, _, c in branches]

        return branches, branch_groups

    def generate_batch_trees(
        self, world_bounds=np.array([0.0, -10.0, 0.0, 25.0, 10.0, 10.0]), num_batches=1
    ):
        """
        Generate multiple trees at random positions within world bounds.

        Args:
            world_bounds: Array/list of 6 elements [x_min, y_min, z_min, x_max, y_max, z_max]
            num_batches: Number of trees to generate

        Returns:
            List of branch lists, one for each generated tree
        """
        # Validate input
        if len(world_bounds) != 6:
            raise ValueError(
                "world_bounds must have 6 elements: [x_min, y_min, z_min, x_max, y_max, z_max]"
            )

        total_branches = []
        total_branch_groups = []
        buffer = 6

        # For if random starting pose
        # x_min, y_min, z_min = world_bounds[0], world_bounds[1], world_bounds[2]
        # x_max, y_max, z_max = world_bounds[3], world_bounds[4], world_bounds[5]

        # # Ensure we have enough space after applying buffer
        # if (x_max - x_min) <= 2 * buffer or (y_max - y_min) <= 2 * buffer:
        #     print(f"Warning: Buffer ({buffer}) may be too large for world bounds")

        for i in range(num_batches):
            # Generate random position within buffered bounds
            # x = np.random.uniform(x_min + buffer, x_max - buffer)
            # y = np.random.uniform(y_min + buffer, y_max - buffer)
            # z = z_min

            # pos = np.array([x, y, z])
            
            flat_branches, grouped_branches = self._generate_branches()
            total_branches.append(flat_branches)
            total_branch_groups.append(grouped_branches)

        return total_branches, total_branch_groups

    def visualize_3d(
        self,
        title="L-System 3D Visualization",
        branch_colors=None,
        figsize=(12, 9),
        elev=25,
        azim=-60,
    ):
        """Creates a 3D visualization of the L-system using matplotlib."""
        if branch_colors is None:
            branch_colors = {
                "F": "saddlebrown",
                "S": "darkgreen",
                "L": "green",
                "C": "limegreen",
                "A": "orange",
                "default": "gray",
            }

        fig = plt.figure(figsize=figsize)
        ax = fig.add_subplot(111, projection="3d")

        all_points = [np.array([0.0, 0.0, 0.0])]
        for start, end, btype, diameter, color in self.branches:
            # Use diameter to set linewidth (with a minimum width)
            linewidth = max(0.5, diameter * 2.0)
            ax.plot(
                *zip(start, end),
                color=branch_colors.get(btype, "gray"),
                linewidth=linewidth,
            )
            all_points.extend([start, end])

        # Set plot limits to create a bounding box
        pts = np.array(all_points)
        max_range = (pts.max(axis=0) - pts.min(axis=0)).max() / 2.0
        mid = (pts.max(axis=0) + pts.min(axis=0)) / 2.0
        ax.set_xlim(mid[0] - max_range, mid[0] + max_range)
        ax.set_ylim(mid[1] - max_range, mid[1] + max_range)
        ax.set_zlim(mid[2] - max_range, mid[2] + max_range)

        ax.set_xlabel("X")
        ax.set_ylabel("Y")
        ax.set_zlabel("Z")
        ax.set_title(title)
        ax.view_init(elev=elev, azim=azim)
        plt.tight_layout()
        plt.show()

    def visualize_grouped_branches(
        self,
        title="Grouped Branches Visualization",
        figsize=(12, 9),
        elev=25,
        azim=-60,
        num_colors=20,
        use_branch_colors=False,
    ):
        """
        Visualizes branches grouped by their alignment.
        
        Args:
            title: Plot title
            figsize: Figure size tuple
            elev: Elevation angle for 3D view
            azim: Azimuth angle for 3D view
            num_colors: Number of random colors to use (only if use_branch_colors=False)
            use_branch_colors: If True, use actual branch colors (G=green, B=brown).
                              If False, use random colors from palette for each group.
        """
        fig = plt.figure(figsize=figsize)
        ax = fig.add_subplot(111, projection="3d")

        all_points = [np.array([0.0, 0.0, 0.0])]

        # Color mapping for branch colors
        branch_color_map = {
            'G': 'green',
            'B': 'saddlebrown',
        }

        # Define a distinct color palette (20 visually distinct colors)
        color_palette = [
            "#e6194b", "#3cb44b", "#ffe119", "#4363d8", "#f58231",
            "#911eb4", "#46f0f0", "#f032e6", "#bcf60c", "#fabebe",
            "#008080", "#e6beff", "#9a6324", "#fffac8", "#800000",
            "#aaffc3", "#808000", "#ffd8b1", "#000075", "#808080"
        ]
        
        # Trim or extend palette based on num_colors parameter
        colors = color_palette[:num_colors]
        
        # Randomly assign colors to each group (only used if use_branch_colors=False)
        np.random.seed(42)  # For reproducibility; remove this line for true randomness
        group_colors = np.random.choice(colors, size=len(self.branch_groups), replace=True)

        for group_index, group in enumerate(self.branch_groups):
            for start, end, btype, diameter, branch_color in group:
                linewidth = max(0.5, diameter * 2.0)
                
                # Choose color based on mode
                if use_branch_colors:
                    plot_color = branch_color_map.get(branch_color, 'gray')
                else:
                    plot_color = group_colors[group_index]
                
                ax.plot(
                    *zip(start, end),
                    color=plot_color,
                    linewidth=linewidth,
                    alpha=0.9,
                )
                all_points.extend([start, end])

        # Set plot limits to create a bounding box
        pts = np.array(all_points)
        max_range = (pts.max(axis=0) - pts.min(axis=0)).max() / 2.0
        mid = (pts.max(axis=0) + pts.min(axis=0)) / 2.0
        ax.set_xlim(mid[0] - max_range, mid[0] + max_range)
        ax.set_ylim(mid[1] - max_range, mid[1] + max_range)
        ax.set_zlim(mid[2] - max_range, mid[2] + max_range)

        ax.set_xlabel("X")
        ax.set_ylabel("Y")
        ax.set_zlabel("Z")
        if use_branch_colors:
            ax.set_title(f"{title}\n{len(self.branch_groups)} groups (Green/Brown branch colors)")
        else:
            ax.set_title(f"{title}\n{len(self.branch_groups)} groups with {num_colors} random colors")
        ax.view_init(elev=elev, azim=azim)
        plt.tight_layout()
        plt.show()


if __name__ == "__main__":
    np.random.seed(0)
    name, axiom, rule = ZONO_TREE
    lsystem = LSystem(axiom=axiom, rule=rule)
    lsystem.iterate(iterations=7)

    lsystem.remove_symbol("A")
    string = lsystem.state

    print(f"Processing L-System for '{name}' with {len(string)} commands...")
    print(lsystem.get_rule_statistics())

    # Create the visualizer object
    tree_viz = LSystemTree(
        string,
        branch_length=0.2,
        angle_deg=22.5,
        initial_diameter=10.0,
        diameter_scale=0.85,
    )

    # Visualize regular branches
    # print("\nCreating standard 3D visualization...")
    # tree_viz.visualize_3d(title="Standard 3D L-System Tree")
    
    print(lsystem.estimate_branch_groups(lsystem.state))

    # Visualize grouped branches with unique colors per group
    print("\nCreating grouped branches visualization...")
    tree_viz.visualize_grouped_branches(
        title="Grouped Branches (Random Colors)",
        num_colors=20,  
        use_branch_colors=True
    )

