import numpy as np
from treelib.tree import Tree

import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from algorithm.lsystem import LSystem
from utils.constants import TREE_EXAMPLE



class LSystemTree:
    """
    Parses a 3D L-system string and represents it as a node-based tree
    using the treelib library. Provides methods to extract geometric data.
    """
    def __init__(self, lsystem_string, branch_length=1.0, angle_deg=22.5):
        """
        Initializes and builds the tree from an L-system string.

        Args:
            lsystem_string (str): The string generated by the L-system rules.
            branch_length (float): The length of each 'F' or 'S' segment.
            angle_deg (float): The angle in degrees for rotation commands (+, -, etc.).
        """
        self.lsystem_string = lsystem_string
        self.branch_length = branch_length
        self.angle_rad = np.radians(angle_deg)
        self.tree = Tree()
        
        # Build the tree upon instantiation
        self._build_tree()

    def _get_rotation_matrix(self, axis, theta):
        """
        Return the rotation matrix associated with counter-clockwise rotation
        about the given axis by theta radians.
        (Uses the Euler-Rodrigues formula)
        """
        axis = np.asarray(axis)
        axis = axis / np.sqrt(np.dot(axis, axis))
        a = np.cos(theta / 2.0)
        b, c, d = -axis * np.sin(theta / 2.0)
        aa, bb, cc, dd = a * a, b * b, c * c, d * d
        bc, ad, ac, ab, bd, cd = b * c, a * d, a * c, a * b, b * d, c * d
        return np.array([[aa + bb - cc - dd, 2 * (bc + ad), 2 * (bd - ac)],
                         [2 * (bc - ad), aa + cc - bb - dd, 2 * (cd + ab)],
                         [2 * (bd + ac), 2 * (cd - ab), aa + dd - bb - cc]])

    def _build_tree(self):
        """
        Parses the L-system string using a 3D turtle and constructs the
        treelib.Tree object.
        """
        stack = []
        
        # Turtle's initial state
        position = np.array([0.0, 0.0, 0.0])
        # Orientation vectors: heading is forward, left is for yaw, up is for pitch/roll
        heading_vec = np.array([0.0, 0.0, 1.0]) # Start by growing up the Z-axis (vertical)
        left_vec = np.array([1.0, 0.0, 0.0])    # Left is along X-axis
        up_vec = np.cross(heading_vec, left_vec) # Up is along Y-axis (cross product)

        # Unique identifier for each node
        node_counter = 0
        
        # Create the root of the tree at the origin
        self.tree.create_node(
            tag="root",
            identifier=str(node_counter),
            data={'pos': position, 'type': 'root'}
        )
        current_node_id = node_counter

        # Process the L-system string
        for char in self.lsystem_string:
            # --- Rotation operations ---
            if char == '+': # Yaw Right
                rot_mat = self._get_rotation_matrix(up_vec, self.angle_rad)
                heading_vec = np.dot(rot_mat, heading_vec)
                left_vec = np.dot(rot_mat, left_vec)
            elif char == '-': # Yaw Left
                rot_mat = self._get_rotation_matrix(up_vec, -self.angle_rad)
                heading_vec = np.dot(rot_mat, heading_vec)
                left_vec = np.dot(rot_mat, left_vec)
            elif char == '&': # Pitch Down
                rot_mat = self._get_rotation_matrix(left_vec, self.angle_rad)
                heading_vec = np.dot(rot_mat, heading_vec)
                up_vec = np.dot(rot_mat, up_vec)
            elif char == '^': # Pitch Up
                rot_mat = self._get_rotation_matrix(left_vec, -self.angle_rad)
                heading_vec = np.dot(rot_mat, heading_vec)
                up_vec = np.dot(rot_mat, up_vec)
            elif char == '\\': # Roll Left
                rot_mat = self._get_rotation_matrix(heading_vec, self.angle_rad)
                left_vec = np.dot(rot_mat, left_vec)
                up_vec = np.dot(rot_mat, up_vec)
            elif char == '/': # Roll Right
                rot_mat = self._get_rotation_matrix(heading_vec, -self.angle_rad)
                left_vec = np.dot(rot_mat, left_vec)
                up_vec = np.dot(rot_mat, up_vec)
            elif char == '|': # Turn around (180 deg yaw)
                rot_mat = self._get_rotation_matrix(up_vec, np.pi)
                heading_vec = np.dot(rot_mat, heading_vec)
                left_vec = np.dot(rot_mat, left_vec)

            # --- Stack operations ---
            elif char == '[':
                stack.append((position, heading_vec, left_vec, up_vec, current_node_id))
            elif char == ']':
                position, heading_vec, left_vec, up_vec, current_node_id = stack.pop()
            
            # --- Drawing operations ---
            elif char in ['F', 'S', 'L', 'A']:
                # Move forward and create a new node
                position = position + heading_vec * self.branch_length
                node_counter += 1
                
                self.tree.create_node(
                    tag=char,
                    identifier=str(node_counter),
                    parent=str(current_node_id),
                    data={'pos': position, 'type': char}
                )
                current_node_id = node_counter

    def get_branches(self):
        """
        Traverses the generated tree and returns a list of all branches.

        Returns:
            list: A list of tuples, where each tuple represents a branch
                  and contains (start_point, end_point, branch_type).
                  Points are NumPy arrays.
        """
        branches = []
        all_nodes = self.tree.all_nodes()

        for node in all_nodes:
            if not node.is_root():
                parent = self.tree.parent(node.identifier)
                
                if parent and parent.data:
                    start_point = parent.data['pos']
                    end_point = node.data['pos']
                    branch_type = node.data['type']
                    
                    branches.append((start_point, end_point, branch_type))
        
        return branches

    def visualize_3d(self, title="L-System Tree 3D Visualization", show_nodes=True, 
                     branch_colors=None, node_size=50, line_width=2, figsize=(12, 9),
                     elev=25, azim=-60):
        """
        Creates a 3D visualization of the L-system tree using matplotlib.
        
        Args:
            title (str): Title for the plot
            show_nodes (bool): Whether to show nodes as points
            branch_colors (dict): Dictionary mapping branch types to colors
            node_size (int): Size of the node markers
            line_width (int): Width of the branch lines
            figsize (tuple): Figure size (width, height)
            elev (int): Elevation angle for 3D view (0-90 degrees) - good for trees growing up Z-axis
            azim (int): Azimuth angle for 3D view (0-360 degrees)
        """
        # Import here to avoid unused import warnings when method isn't called
        import matplotlib.pyplot as plt
        from matplotlib.lines import Line2D
        
        # Default colors for different branch types
        if branch_colors is None:
            branch_colors = {
                'F': 'brown',      # Main stem/trunk
                'S': 'darkgreen',  # Secondary branches
                'L': 'green',      # Leaves/foliage
                'A': 'orange',     # Additional elements
                'root': 'black'    # Root
            }
        
        # Create the 3D plot
        fig = plt.figure(figsize=figsize)
        ax = fig.add_subplot(111, projection='3d')
        
        # Get all branches
        branches = self.get_branches()
        
        # Track all points for setting axis limits
        all_points = []
        
        # Draw branches
        for start_point, end_point, branch_type in branches:
            # Get color for this branch type
            color = branch_colors.get(branch_type, 'gray')
            
            # Extract coordinates
            x_coords = [start_point[0], end_point[0]]
            y_coords = [start_point[1], end_point[1]]
            z_coords = [start_point[2], end_point[2]]
            
            # Draw the branch
            ax.plot(x_coords, y_coords, z_coords, 
                   color=color, linewidth=line_width, alpha=0.8)
            
            # Collect points for axis limits
            all_points.extend([start_point, end_point])
        
        # Draw nodes if requested
        if show_nodes and all_points:
            all_nodes = self.tree.all_nodes()
            for node in all_nodes:
                pos = node.data['pos']
                node_type = node.data['type']
                color = branch_colors.get(node_type, 'red')
                
                ax.scatter(pos[0], pos[1], pos[2], 
                          color=color, s=node_size, alpha=0.7)
        
        # Set equal aspect ratio and nice limits
        if all_points:
            all_points = np.array(all_points)
            
            # Calculate bounds with some padding
            x_min, x_max = all_points[:, 0].min(), all_points[:, 0].max()
            y_min, y_max = all_points[:, 1].min(), all_points[:, 1].max()
            z_min, z_max = all_points[:, 2].min(), all_points[:, 2].max()
            
            # Add padding (10% of range)
            x_range = x_max - x_min if x_max != x_min else 1
            y_range = y_max - y_min if y_max != y_min else 1
            z_range = z_max - z_min if z_max != z_min else 1
            
            padding = 0.1
            ax.set_xlim(x_min - padding * x_range, x_max + padding * x_range)
            ax.set_ylim(y_min - padding * y_range, y_max + padding * y_range)
            ax.set_zlim(z_min - padding * z_range, z_max + padding * z_range)
            
            # Set equal aspect ratio for better tree visualization
            max_range = max(x_range, y_range, z_range)
            ax.set_box_aspect([x_range/max_range, y_range/max_range, z_range/max_range])
        
        # Labels and title
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_zlabel('Z')
        ax.set_title(title)
        
        # Create legend for branch types
        if branches:
            legend_elements = []
            used_types = set(branch_type for _, _, branch_type in branches)
            for branch_type in used_types:
                color = branch_colors.get(branch_type, 'gray')
                legend_elements.append(Line2D([0], [0], color=color, 
                                            linewidth=line_width, label=f"Type '{branch_type}'"))
            
            if legend_elements:
                ax.legend(handles=legend_elements, loc='upper right')
        
        # Improve the view - optimized for tree visualization
        # Trees now grow upward (Z-axis), so we want a good elevated view
        ax.view_init(elev=elev, azim=azim)
        
        # Enable interactive rotation and zooming
        ax.mouse_init()
        
        # Show the plot
        plt.tight_layout()
        plt.show()
        
        return fig, ax

    def show(self):
        """Prints a visual representation of the tree structure."""
        self.tree.show()

# --- Example Usage ---
if __name__ == '__main__':
    # A simple 3D L-system string
    # It creates a main stem, a branch to the right (+),
    # and another branch that pitches down (&)
    # example_string = "F[+F]F[-&F]"
    
    name, axiom, rule = TREE_EXAMPLE
    lsystem = LSystem(axiom=axiom, rule=rule)
    lsystem.iterate(iterations=3)
    
    string = lsystem.state
    
    print(f"Processing L-System String: {string}\n")

    # Create the tree object
    lsystem_tree = LSystemTree(string, branch_length=1.5, angle_deg=30)
    
    # Print the hierarchical structure of the tree
    # print("--- Tree Structure ---")
    # lsystem_tree.show()
    
    # Get the list of branches
    # branch_list = lsystem_tree.get_branches()
    
    # print("\n--- Branch List ---")
    # print("Format: (start_point, end_point, branch_type)")
    # for i, (start, end, btype) in enumerate(branch_list):
    #     # Format numpy arrays for cleaner printing
    #     start_str = np.array2string(start, precision=2, separator=', ')
    #     end_str = np.array2string(end, precision=2, separator=', ')
    #     print(f"Branch {i+1}: ({start_str}, {end_str}, '{btype}')")
    
    # Visualize the tree in 3D
    print("\n--- 3D Visualization ---")
    print("Creating 3D visualization of the tree...")
    
    # Create the visualization with custom colors
    custom_colors = {
        'F': 'saddlebrown',    # Main branches
        'S': 'forestgreen',    # Secondary branches  
        'L': 'limegreen',      # Leaves
        'A': 'orange',         # Additional elements
        'root': 'black'        # Root
    }
    
    # This will open a matplotlib window with the 3D visualization
    lsystem_tree.visualize_3d(
        title="3D L-System Tree Example", 
        show_nodes=True,
        branch_colors=custom_colors,
        node_size=60,
        line_width=3
    )
